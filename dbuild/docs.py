"""Documentation and Containerfile generation from compose.yaml metadata.
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Any

try:
    import yaml
except ImportError:
    yaml = None

try:
    import jinja2
except ImportError:
    jinja2 = None

from dbuild import log
from dbuild.config import Config

# Constants for placeholder generation
CONFIG_ROOT_VAR = "@CONTAINER_CONFIG_ROOT@"
SHARED_PATHS = ["/downloads", "/movies", "/tv", "/music", "/books", "/media", "/data"]

HEADER_TEMPLATE = """# --------------------------------------------------------------------------
# THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY
#
# Source: {source}
# --------------------------------------------------------------------------

"""

README_HEADER = """<!--
THIS FILE IS AUTOGENERATED - DO NOT EDIT MANUALLY
Source: dbuild templates
-->

"""

def _get_jinja_env(base: Path) -> jinja2.Environment | None:
    """Create Jinja2 environment looking first in .daemonless/templates, then bundled."""
    if jinja2 is None:
        return None

    search_paths = [
        base / ".daemonless" / "templates",
        Path(__file__).parent / "templates",
    ]
    # Filter to existing directories
    loaders = [jinja2.FileSystemLoader(str(p)) for p in search_paths if p.is_dir()]
    if not loaders:
        return None

    return jinja2.Environment(loader=jinja2.ChoiceLoader(loaders))

def _enrich_metadata(cfg: Config) -> dict[str, Any]:
    """Build a context dict for templates with enriched env/vol/port data from Config."""
    meta = cfg.metadata
    docs = meta.docs if isinstance(meta.docs, dict) else {}

    # Check for mlock annotation
    annotations = cfg.test.annotations if cfg.test else []
    mlock = any("allow.mlock=true" in a.replace(" ", "") for a in annotations)

    context = {
        "name": cfg.image,
        "title": meta.title,
        "description": meta.description,
        "category": meta.category,
        "upstream_url": meta.upstream_url,
        "web_url": meta.web_url,
        "freshports_url": meta.freshports_url,
        "user": meta.user,
        "mlock": mlock,
        "annotations": annotations,
        "upstream_binary": meta.upstream_binary,
        "icon": meta.icon,
        "healthcheck": meta.healthcheck,
        "notes": meta.notes,
        "repo_url": f"https://github.com/daemonless/{cfg.image}",
        "tags": [v.tag for v in cfg.variants],
        "architectures": cfg.architectures,
        "env": [],
        "volumes": [],
        "ports": [],
    }

    # Environment
    env_docs = {str(k): v for k, v in docs.get("env", {}).items()}
    for e in cfg.env:
        name = e["name"]
        val = e["default"]

        display_val = val if val and val not in ['""', "''"] else ""
        if not display_val and any(x in name.upper() for x in ["PASS", "KEY", "SECRET", "TOKEN"]):
            display_val = f"<{name.upper()}>"

        item = {"name": name, "default": display_val, "desc": env_docs.get(str(name), "")}
        if name in ["PUID", "PGID", "TZ"]:
            item["placeholder"] = f"@{name}@"
        context["env"].append(item)

    # Volumes
    vol_docs = {str(k): v for k, v in docs.get("volumes", {}).items()}
    for v in cfg.volumes:
        src = v["source"]
        tgt = v["target"]

        clean_target = tgt.strip("/").replace("/", "_").upper()
        vol_info = vol_docs.get(str(tgt), "")
        desc = vol_info.get("desc", "") if isinstance(vol_info, dict) else str(vol_info)
        optional = vol_info.get("optional", False) if isinstance(vol_info, dict) else False

        if tgt in SHARED_PATHS:
            source_path = tgt.lstrip("/")
            placeholder = f"@{clean_target}_PATH@"
            root_var = None
        elif tgt == "/config":
            placeholder = f"@{cfg.image.upper().replace('-', '_')}_CONFIG_PATH@"
            source_path = cfg.image
            root_var = CONFIG_ROOT_VAR
        elif src.startswith("./") or src.startswith("."):
            clean_src = src.lstrip("./")
            source_path = f"{cfg.image}/{clean_src}"
            root_var = CONFIG_ROOT_VAR
            placeholder = f"@{cfg.image.upper().replace('-', '_')}_{clean_src.upper()}_PATH@"
        else:
            source_path = f"{cfg.image}{tgt}"
            root_var = CONFIG_ROOT_VAR
            placeholder = f"@{cfg.image.upper().replace('-', '_')}_{clean_target}_PATH@"

        context["volumes"].append({
            "path": tgt,
            "desc": desc,
            "optional": optional,
            "placeholder": placeholder,
            "source": source_path,
            "root_var": root_var
        })

    # Ports
    port_docs = {str(k): v for k, v in docs.get("ports", {}).items()}
    for p in cfg.ports:
        pub = p["published"]
        tgt = p["target"]
        proto = p["protocol"]

        context["ports"].append({
            "port": pub,
            "protocol": proto,
            "desc": port_docs.get(str(pub), ""),
            "name": "web"
        })

    return context

def run(cfg: Config, args: argparse.Namespace) -> int:
    """Generate documentation and Containerfiles."""
    if jinja2 is None:
        log.error("Jinja2 is not installed. Code generation requires it.")
        log.info("Run: pip install jinja2")
        return 1

    base = Path.cwd()
    context = _enrich_metadata(cfg)
    env = _get_jinja_env(base)
    if not env:
        log.error("Could not find dbuild templates.")
        return 1

    # 1. Generate README.md (if docs: manual isn't set)
    is_manual = (cfg.metadata.docs == "manual" or
                 (isinstance(cfg.metadata.docs, dict) and cfg.metadata.docs.get("manual", False)))

    if is_manual:
        log.info("Skipping README.md generation (docs: manual)")
    else:
        try:
            template = env.get_template("README.j2")
            # README.md uses HTML comments for autogen header
            content = README_HEADER + template.render(context, render_mode="github")
            (base / "README.md").write_text(content)
            log.step("Generated README.md")
        except jinja2.TemplateNotFound:
            log.warn("README.j2 template not found, skipping README.md")

    # 2. Generate Containerfiles from .j2 templates
    for j2_path in base.glob("Containerfile*.j2"):
        out_name = j2_path.name.replace(".j2", "")
        try:
            # We use a separate env for local repo files to allow including local templates
            repo_env = jinja2.Environment(loader=jinja2.FileSystemLoader(str(base)))
            template = repo_env.get_template(j2_path.name)

            content = HEADER_TEMPLATE.format(source=j2_path.name) + template.render(context)
            (base / out_name).write_text(content)
            log.step(f"Generated {out_name}")
        except Exception as e:
            log.error(f"Failed to generate {out_name}: {e}")

    return 0
